<!--
 * @Author: ZYH
 * @Email: 1522302196@qq.com
 * @GiteeId: colincclala
 * @Date: 2022-05-17 11:26:42
 * @LastEditTime: 2022-05-18 10:35:54
 * @Description: Event Loop
-->
# Event Loop

[大佬的文章](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)

## js是单线程

- JavaScript的主要用途是与用户互动，以及操作DOM，所以只能是单线程，否则有同步问题。

## 任务队列

- 同步任务（synchronous）和异步任务（asynchronous）
    - 同步任务：**在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务**。
    - 异步任务：**不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行**。
> 异步执行的运行机制
> > 1. 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
> > 2. 主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
> > 3. 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
> > 4. 主线程不断重复上面的第三步。

- **只要主线程空了，就会去读取"任务队列"，这就是JavaScript的运行机制。这个过程会不断重复**。

## 事件和回调函数

- "任务队列"是一个事件的队列，先进先出的数据结构。

- "回调函数"（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。


## Event Loop

- 主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为`Event Loop`（事件循环）。

- 只要栈中的代码执行完毕，主线程就会去读取"任务队列"，依次执行那些事件所对应的回调函数。

## 定时器

- 定时器功能主要由`setTimeout()`(一次性执行)和`setInterval()`(反复执行)这两个函数来完成。
    - `setTimeout()`接受两个参数，第一个是回调函数，第二个是推迟执行的毫秒数。
        > 如果将setTimeout()的第二个参数设为0，就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。
        - `setTimeout(fn,0)`的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在"任务队列"的尾部添加一个事件，因此要等到同步任务和"任务队列"现有的事件都处理完，才会得到执行。



## Node.js的Event Loop

- Node.js也是**单线程**的Event Loop，但是它的运行机制不同于浏览器环境。
    1. V8引擎解析JavaScript脚本。
    2. 解析后的代码，调用Node API。
    3. libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。
    4. V8引擎再将结果返回给用户。

- Node.js还提供了另外两个与"任务队列"有关的方法：`process.nextTick`和`setImmediate`。
    1. `process.nextTick`方法可以在当前"执行栈"的尾部----下一次Event Loop（主线程读取"任务队列"）之前----触发回调函数。也就是说，**它指定的任务总是发生在所有异步任务之前**。
    2. `etImmediate`方法则是在当前"任务队列"的尾部添加事件，也就是说，它指定的任务总是在下一次Event Loop时执行，这与setTimeout(fn, 0)很像。

    > 区别：多个process.nextTick语句总是在当前"执行栈"一次执行完，多个setImmediate可能则需要多次loop才能执行完。事实上，这正是Node.js 10.0版添加setImmediate方法的原因，否则像下面这样的递归调用process.nextTick，将会没完没了，主线程根本不会去读取"事件队列"！
        ```js
        process.nextTick(function foo() {
            process.nextTick(foo);
        });
        ```