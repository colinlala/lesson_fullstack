# 函数的扩展

## 函数参数的默认值

- ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。
- 参数变量是默认声明的，所以不能用let或const再次声明。
    ```
    function foo(x = 5) {
        let x = 1; // error
        const x = 2; // error
    }
    // 参数变量x是默认声明的，在函数体中，不能用let或const再次声明，否则会报错。
    ```
> 参数默认值不是传值的，而是每次都重新计算默认值表达式的值。

- 通过提供函数参数的默认值，避免函数调用时没有提供参数的报错
    ```
    function foo({x, y = 5} = {}) {
        console.log(x, y);
    }
    foo() // undefined 5
    // 如果没有提供参数，函数foo的参数默认为一个空对象。
    ```

- 函数参数的默认值生效以后，参数解构赋值依然会进行。
    ```
    function f({ a, b = 'world' } = { a: 'hello' }) {
        console.log(b);
    }
    f() // world
    // 函数f()调用时没有参数，所以参数默认值{ a: 'hello' }生效，然后再对这个默认值进行解构赋值，从而触发参数变量b的默认值生效。
    ```

- 若尾参数是默认值，则传入时可忽略。**传入undefined**，触发尾参数等于默认值。

- 参数指定了默认值后，函数的length属性将失真。（**返回没有指定默认指的参数个数**）

- 设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域。
    ```
    let x = 1;
    function f(y = x) {
        let x = 2;
        console.log(y);
    }
    f() // 1
    // 函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。
    ```
    > 如果参数的**默认值是一个函数**，该函数的作用域也遵守这个规则。

## rest参数

- ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数。
    1. 就不需要用arguments
    2. arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.from先将其转为数组。
    3. rest 参数，它就是一个真正的数组，数组特有的方法都可以使用。

> rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。

## 严格模式

- 只要函数参数使用了***默认值、解构赋值、或者扩展运算符***，那么函数内部就**不能**显式设定为严格模式，否则会报错。


## name属性

- 返回该函数的函数名。
- 如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。
    ```
    var f = function () {};
    // ES5
    f.name // ""
    // ES6
    f.name // "f"
    ```
- Function构造函数返回的函数实例，name属性的值为anonymous。
    ```
    (new Function).name // "anonymous"
    ```
- bind返回的函数，name属性值会加上bound前缀。
    ```
    function foo() {};
    foo.bind({}).name // "bound foo"
    (function(){}).bind({}).name // "bound "
    ```

## 箭头函数
（没有this，没有arguments，没有super，没有new.target）

- 大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。
    ```
    let getTempItem = id => ({ id: id, name: "Temp" });// 不报错
    ```

- 箭头函数的一个用处是简化回调函数。


1. 箭头函数***没有自己的this对象***。
2. ***不可以当作构造函数***，也就是说，不可以对箭头函数使用new命令，否则会抛出一个错误。
3. ***不可以使用arguments对象***，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
4. ***不可以使用yield命令***，因此箭头函数不能用作 Generator 函数。


```
function foo() {
  setTimeout(() => {
    console.log('id:', this.id);
  }, 100);
}
var id = 21;
foo.call({ id: 42 });// id: 42
// setTimeout()的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到 100 毫秒后。
//如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。
//但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以打印出来的是42。
```

> 箭头函数：this总是指向函数定义生效时所在的对象。普通函数：执行时this应该指向作用域的对象

- 箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。


## 尾调用优化

- 尾调用（Tail Call），就是指某个函数的最后一步是调用另一个函数（调用后还有赋值操作不算）。尾调用不一定出现在函数尾部，只要是最后一步操作即可。

- A的内部调用B，此时在A的调用帧上形成B的调用帧，等B运行完结果返回A，则B的调用帧消失。...以此类推。

    ```
    function f() {
        let m = 1;
        let n = 2;
        return g(m + n);
    }
    f();

    // 等同于
    function f() {
        return g(3);
    }
    f();

    // 等同于
    g(3);
    ```
    - “尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。

        > 1. 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。
        > 2. 注意，目前只有 Safari 浏览器支持尾调用优化，Chrome 和 Firefox 都不支持。



- 如果尾调用自身，就称为**尾递归**。
- ES6 中只要使用尾递归，就不会发生栈溢出（或者层层递归造成的超时），相对节省内存。

> ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。


## 函数参数的尾逗号 

## Function.prototype.toString()

- toString()方法返回函数代码本身，以前会省略注释和空格。
    ```
    function /* foo comment */ foo () {}
    foo.toString()
    // "function /* foo comment */ foo () {}"
    ```


## catch 命令的参数省略

- JavaScript 语言的try...catch结构，以前明确要求catch命令后面必须跟参数，接受try代码块抛出的错误对象。
    ```
    try {
        // ...
    } catch {
        // ...
    }
    ```