<<<<<<< HEAD
# 数组的扩展


## 扩展运算符（...）

- 如果扩展运算符后面是一个空数组，则不产生任何效果。
- *只有函数调用时，扩展运算符才可以放在圆括号中*，否则会报错。
- 替代apply(),展开数组。

1. 复制数组
    > 数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。


        ```
        const a1 = [1, 2];
        const a2 = a1;   
        a2[0] = 2;
        a1 // [2, 2]
        // a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2，会直接导致a1的变化。

        const a1 = [1, 2];
        // 写法一
        const a2 = [...a1];    // es5 =a1.concat();
        // 写法二
        const [...a2] = a1;
        // a2都是a1的克隆
        ```
2. 合并数组
    - ***浅拷贝***
        ```
        const a1 = [{ foo: 1 }];
        const a2 = [{ bar: 2 }];
        const a4 = [...a1, ...a2];
        a4[0] === a1[0] // true
        // a3和a4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了引用指向的值，会同步反映到新数组。
        ```
3. 与解构赋值结合
    - 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。
        ```
        const [...butLast, last] = [1, 2, 3, 4, 5];  // 报错
        const [first, ...middle, last] = [1, 2, 3, 4, 5];   // 报错
        const [first,last ,...middle ] = [1, 2, 3, 4, 5];   // 没错
        ```

4. 字符串
    - 可以将字符串转为真正的数组。
        ```
        [...'hello']   // [ "h", "e", "l", "l", "o" ]
        ```
    - 正确识别四个字节的 Unicode 字符。

5. 实现了 Iterator 接口的对象
    - 任何定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组。


6. Map 和 Set 结构，Generator 函数
    - 只要具有 Iterator 接口的对象，都可以使用扩展运算符。


## Array.from()

- 将 ***类似数组的对象和可遍历的对象*** 转为真正的数组。

- 只要是部署了 ***Iterator 接口的数据结构***，都能将其转为数组。

- 类似数组的对象***（有length属性的对象）***，都可以转为数组，而此时扩展运算符就无法转换。

> 对于还没有部署该方法的浏览器，可以用Array.prototype.slice()方法替代。

- 可以接受一个函数作为第二个参数，用来对每个元素进行处理，将***处理后的值放入返回的数组***。

- 将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\uFFFF的 Unicode 字符，算作两个字符的 bug。



## Array.of()

- 将一组值，转换为数组。

- 弥补Array()方法，只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数只有一个正整数时，实际上是指定数组的长度。

- 如果没有参数，就返回一个空数组。



## 实例方法copyWithin()

- 将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。会修改当前数组。
    ```
    Array.prototype.copyWithin(target, start = 0, end = this.length)
    ```
    1. target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
    2. start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。
    3. end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。


## 实例方法find()、findIndex()

- find(): 用于找出第一个符合条件的数组成员。
    1. 参数是一个回调函数
    2. 直到找出第一个返回值为true的成员，然后返回该成员。
    3. 如果没有符合条件的成员，则返回undefined。
        ```
        [1, 4, -5, 10].find((n) => n < 0)     // -5
        ```
    4. 可以接受第二个参数，用来绑定回调函数的this对象。
    5. 这个回调函数可以接受三个参数，依次为***当前的值、当前的位置和原数组***。
    6. 可以发现NaN(弥补数组的indexOf的不足。)

- findIndex(): 返回第一个符合条件的数组成员的*位置*。
    1. 如果所有成员都不符合条件，则返回-1。
    2. 可以接受第二个参数，用来绑定回调函数的this对象。
    3. 这个回调函数可以接受三个参数，依次为***当前的值、当前的位置和原数组***。
    4. 可以发现NaN(弥补数组的indexOf的不足。)
    


## 实例方法fill()

- 使用给定值，填充一个数组。
    ```
    ['a', 'b', 'c'].fill(7)   // [7, 7, 7]
    new Array(3).fill(7)    // [7, 7, 7]
    ```
- 接受第二个和第三个参数，用于指定填充的*起始位置和结束位置*。
 
> 如果填充的类型为***对象***，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。

    ```
    let arr = new Array(3).fill({name: "Mike"});
    arr[0].name = "Ben";
    arr    // [{name: "Ben"}, {name: "Ben"}, {name: "Ben"}]
    
    let arr = new Array(3).fill([]);
    arr[0].push(5);
    arr    // [[5], [5], [5]]
    ```

## 实例方法entries()，keys()和values()

- 用于遍历数组。都返回一个遍历器对象。可以用for...of循环进行遍历
    1. keys()是对键名的遍历
    2. values()是对键值的遍历
    3. entries()是对键值对的遍历


## 实例方法includes()

- Array.prototype.includes方法**返回一个布尔值**，表示某个数组是否包含给定的值。
- 识别NaN。
- 第二个参数表示搜索的起始位置，默认为0。
    1. 如果为负数，则表示倒数的位置，
    2. 如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。



- Map 和 Set 数据结构有一个has方法，需要注意与includes区分。

    1. Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。
    2. Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。


## 实例方法flat()、flatMap()

1. Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。
    > 默认拉平一层
        ```
        console.log([1,2,3,[4,5,[6,7]]].flat(2))   //[ 1, 2, 3, 4, 5, 6, 7 ]
        ```
    - 如果原数组有空位，flat()方法会跳过空位。

2. flatMap()方法对原数组的每个成员执行一个函数，然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。
    - 只能展开一层数组。
    - 参数是一个遍历函数，该函数可以接受三个参数，分别是***当前数组成员、当前数组成员的位置（从零开始）、原数组***。
    - 可以有第二个参数，用来绑定遍历函数里面的this。


## 实例方法at()

- 方括号运算符[]在 JavaScript 语言里面，不仅用于数组，还用于对象。对于对象来说，方括号里面就是键名
- 由于 JavaScript 的数组是特殊的对象，所以方括号里面的负数无法再有其他语义了，也就是说，不可能添加新语法来支持负索引。

> at()支持负索引。这个方法不仅可用于数组，也可用于字符串和类型数组
> > 参数位置超出了数组范围，at()返回undefined。


## 数组的空位(避免空位)

- 数组的某一个位置没有任何值
    > 空位不是undefined，某一个位置的值等于undefined，依然是有值的。空位是没有任何值


        ```
        0 in [undefined, undefined, undefined] // true
        0 in [, , ,] // false
        // 第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。
        ```

- es5
    1. forEach(), filter(), reduce(), every() 和some()都会跳过空位。
    2. map()会跳过空位，但会保留这个值
    3. join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。

- es6:明确将空位转为undefined。
    1. map()方法遍历，空位是会跳过的。


- 所以建议避免出现空位。


## Array.prototype.sort() 的排序稳定性

1. 插入排序、合并排序、冒泡排序等都是稳定的，
=======
# 数组的扩展


## 扩展运算符（...）

- 如果扩展运算符后面是一个空数组，则不产生任何效果。
- *只有函数调用时，扩展运算符才可以放在圆括号中*，否则会报错。
- 替代apply(),展开数组。

1. 复制数组
    > 数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。


        ```
        const a1 = [1, 2];
        const a2 = a1;   
        a2[0] = 2;
        a1 // [2, 2]
        // a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2，会直接导致a1的变化。

        const a1 = [1, 2];
        // 写法一
        const a2 = [...a1];    // es5 =a1.concat();
        // 写法二
        const [...a2] = a1;
        // a2都是a1的克隆
        ```
2. 合并数组
    - ***浅拷贝***
        ```
        const a1 = [{ foo: 1 }];
        const a2 = [{ bar: 2 }];
        const a4 = [...a1, ...a2];
        a4[0] === a1[0] // true
        // a3和a4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了引用指向的值，会同步反映到新数组。
        ```
3. 与解构赋值结合
    - 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。
        ```
        const [...butLast, last] = [1, 2, 3, 4, 5];  // 报错
        const [first, ...middle, last] = [1, 2, 3, 4, 5];   // 报错
        const [first,last ,...middle ] = [1, 2, 3, 4, 5];   // 没错
        ```

4. 字符串
    - 可以将字符串转为真正的数组。
        ```
        [...'hello']   // [ "h", "e", "l", "l", "o" ]
        ```
    - 正确识别四个字节的 Unicode 字符。

5. 实现了 Iterator 接口的对象
    - 任何定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组。


6. Map 和 Set 结构，Generator 函数
    - 只要具有 Iterator 接口的对象，都可以使用扩展运算符。


## Array.from()

- 将 ***类似数组的对象和可遍历的对象*** 转为真正的数组。

- 只要是部署了 ***Iterator 接口的数据结构***，都能将其转为数组。

- 类似数组的对象***（有length属性的对象）***，都可以转为数组，而此时扩展运算符就无法转换。

> 对于还没有部署该方法的浏览器，可以用Array.prototype.slice()方法替代。

- 可以接受一个函数作为第二个参数，用来对每个元素进行处理，将***处理后的值放入返回的数组***。

- 将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\uFFFF的 Unicode 字符，算作两个字符的 bug。



## Array.of()

- 将一组值，转换为数组。

- 弥补Array()方法，只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数只有一个正整数时，实际上是指定数组的长度。

- 如果没有参数，就返回一个空数组。



## 实例方法copyWithin()

- 将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。会修改当前数组。
    ```
    Array.prototype.copyWithin(target, start = 0, end = this.length)
    ```
    1. target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
    2. start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。
    3. end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。


## 实例方法find()、findIndex()

- find(): 用于找出第一个符合条件的数组成员。
    1. 参数是一个回调函数
    2. 直到找出第一个返回值为true的成员，然后返回该成员。
    3. 如果没有符合条件的成员，则返回undefined。
        ```
        [1, 4, -5, 10].find((n) => n < 0)     // -5
        ```
    4. 可以接受第二个参数，用来绑定回调函数的this对象。
    5. 这个回调函数可以接受三个参数，依次为***当前的值、当前的位置和原数组***。
    6. 可以发现NaN(弥补数组的indexOf的不足。)

- findIndex(): 返回第一个符合条件的数组成员的*位置*。
    1. 如果所有成员都不符合条件，则返回-1。
    2. 可以接受第二个参数，用来绑定回调函数的this对象。
    3. 这个回调函数可以接受三个参数，依次为***当前的值、当前的位置和原数组***。
    4. 可以发现NaN(弥补数组的indexOf的不足。)
    


## 实例方法fill()

- 使用给定值，填充一个数组。
    ```
    ['a', 'b', 'c'].fill(7)   // [7, 7, 7]
    new Array(3).fill(7)    // [7, 7, 7]
    ```
- 接受第二个和第三个参数，用于指定填充的*起始位置和结束位置*。
 
> 如果填充的类型为***对象***，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。

    ```
    let arr = new Array(3).fill({name: "Mike"});
    arr[0].name = "Ben";
    arr    // [{name: "Ben"}, {name: "Ben"}, {name: "Ben"}]
    
    let arr = new Array(3).fill([]);
    arr[0].push(5);
    arr    // [[5], [5], [5]]
    ```

## 实例方法entries()，keys()和values()

- 用于遍历数组。都返回一个遍历器对象。可以用for...of循环进行遍历
    1. keys()是对键名的遍历
    2. values()是对键值的遍历
    3. entries()是对键值对的遍历


## 实例方法includes()

- Array.prototype.includes方法**返回一个布尔值**，表示某个数组是否包含给定的值。
- 识别NaN。
- 第二个参数表示搜索的起始位置，默认为0。
    1. 如果为负数，则表示倒数的位置，
    2. 如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。



- Map 和 Set 数据结构有一个has方法，需要注意与includes区分。

    1. Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。
    2. Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。


## 实例方法flat()、flatMap()

1. Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。
    > 默认拉平一层
        ```
        console.log([1,2,3,[4,5,[6,7]]].flat(2))   //[ 1, 2, 3, 4, 5, 6, 7 ]
        ```
    - 如果原数组有空位，flat()方法会跳过空位。

2. flatMap()方法对原数组的每个成员执行一个函数，然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。
    - 只能展开一层数组。
    - 参数是一个遍历函数，该函数可以接受三个参数，分别是***当前数组成员、当前数组成员的位置（从零开始）、原数组***。
    - 可以有第二个参数，用来绑定遍历函数里面的this。


## 实例方法at()

- 方括号运算符[]在 JavaScript 语言里面，不仅用于数组，还用于对象。对于对象来说，方括号里面就是键名
- 由于 JavaScript 的数组是特殊的对象，所以方括号里面的负数无法再有其他语义了，也就是说，不可能添加新语法来支持负索引。

> at()支持负索引。这个方法不仅可用于数组，也可用于字符串和类型数组
> > 参数位置超出了数组范围，at()返回undefined。


## 数组的空位(避免空位)

- 数组的某一个位置没有任何值
    > 空位不是undefined，某一个位置的值等于undefined，依然是有值的。空位是没有任何值


        ```
        0 in [undefined, undefined, undefined] // true
        0 in [, , ,] // false
        // 第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。
        ```

- es5
    1. forEach(), filter(), reduce(), every() 和some()都会跳过空位。
    2. map()会跳过空位，但会保留这个值
    3. join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。

- es6:明确将空位转为undefined。
    1. map()方法遍历，空位是会跳过的。


- 所以建议避免出现空位。


## Array.prototype.sort() 的排序稳定性

1. 插入排序、合并排序、冒泡排序等都是稳定的，
>>>>>>> 3060b42 (第一次Git提交所有文件)
2. 堆排序、快速排序等是不稳定的。