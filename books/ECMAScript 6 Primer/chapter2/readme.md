# let 和 const 命令

## let 命令

### 基本用法
- ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的*代码块内有效*。
    > var避免使用（全局变量声明）

### 不存在变量提升
- var命令会发生“变量提升”现象
> let命令改变了语法行为，它所声明的变量一定要在声明后使用

### 暂时性死区

```
if (true) {
  // TDZ开始
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}
```
- 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。typeof不再是一个百分之百安全的操作。
- var不报错 var x=x;


### 不允许重复声明
- let不允许在相同作用域内，重复声明同一个变量。

## 块级作用域

- 内可以读外，外不能读内


### 块级作用域与函数声明
- 匿名立即执行函数表达式（匿名 IIFE）不再必要了。
```
// IIFE 写法
(function () {
  var tmp = ...;
  ...
}());

// 块级作用域写法
{
  let tmp = ...;
  ...
}
```

- 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。
```
// 块级作用域内部的函数声明语句，建议不要使用
{
  let a = 'secret';
  function f() {
    return a;
  }
}

// 块级作用域内部，优先使用函数表达式
{
  let a = 'secret';
  let f = function () {
    return a;
  };
}
```

- ES6 的块级作用域必须有**大括号**，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。



## const命令


### 基本用法
- const一旦声明变量，就必须立即初始化，不能留到以后赋值。

### 本质
- const。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。
```
const foo = {};
// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123
// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: "foo" is read-only

// 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。
// -----------------------------------


const a = [];
a.push('Hello'); // 可执行
a.length = 0;    // 可执行
a = ['Dave'];    // 报错

// 常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。
```

### 6种声明变量的方法 var命令和function命令。let和const命令，import命令和class命令

## 顶层对象的属性

- 顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。
> 1. var命令和function命令声明的全局变量，依旧是顶层对象的属性；
> 2. 另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。


## globalThis对象

- 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。
- 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。
- Node 里面，顶层对象是global，但其他环境都不支持。

> 任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。