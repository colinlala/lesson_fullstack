<<<<<<< HEAD
# 词法作用域

- 作用域共有两种主要的工作模型。
    1. 词法作用域
    2. 动态作用域（很少一些还在用）

- 词法作用域就是定义在词法阶段的作用域（代码时将变量和块作用域写在哪里来决定的）。

- 全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性。

## 欺骗词法

- 欺骗词法作用域会导致性能下降。


### eval()接受一个字符串为参数

    ```
    function foo(str, a) {
        eval( str ); // 欺骗！
        console.log( a, b );
    }
    var b = 2;
    foo( "var b = 3;", 1 ); // 1, 3
    ```
1. 在 foo(..) 内部创建了一个变量 b，并遮蔽了外部（全局）作用域中的b。
2. 当 console.log(..) 被执行时，会在 foo(..) 的内部同时找到 a 和 b，但是永远无法找到外部的 b。

- eval(..) 都可以在运行期修改书写期的词法作用域。（严格模式不行）


### with（不推荐使用）

- with 将对象及其属性放进一个全新的作用域并同时分配标识符
=======
# 词法作用域

- 作用域共有两种主要的工作模型。
    1. 词法作用域
    2. 动态作用域（很少一些还在用）

- 词法作用域就是定义在词法阶段的作用域（代码时将变量和块作用域写在哪里来决定的）。

- 全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性。

## 欺骗词法

- 欺骗词法作用域会导致性能下降。


### eval()接受一个字符串为参数

    ```
    function foo(str, a) {
        eval( str ); // 欺骗！
        console.log( a, b );
    }
    var b = 2;
    foo( "var b = 3;", 1 ); // 1, 3
    ```
1. 在 foo(..) 内部创建了一个变量 b，并遮蔽了外部（全局）作用域中的b。
2. 当 console.log(..) 被执行时，会在 foo(..) 的内部同时找到 a 和 b，但是永远无法找到外部的 b。

- eval(..) 都可以在运行期修改书写期的词法作用域。（严格模式不行）


### with（不推荐使用）

- with 将对象及其属性放进一个全新的作用域并同时分配标识符
>>>>>>> 3060b42 (第一次Git提交所有文件)
